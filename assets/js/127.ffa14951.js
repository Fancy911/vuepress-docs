(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{644:function(t,e,s){"use strict";s.r(e);var a=s(2),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("React组件有"),e("strong",[t._v("部分逻辑")]),t._v("都可以直接编写到"),e("strong",[t._v("组件的函数体")]),t._v("中的，比如：")]),t._v(" "),e("ul",[e("li",[t._v("对数组调用"),e("code",[t._v("filter")]),t._v("、"),e("code",[t._v("map")]),t._v("等方法")]),t._v(" "),e("li",[t._v("判断某个组件是否显示等。")])]),t._v(" "),e("p",[t._v("但是有一部分逻辑如果直接写在函数体中，会影响到组件的渲染，这部分会产生“副作用”的代码，是一定不能直接写在函数体中。")]),t._v(" "),e("p",[t._v("例如，如果直接"),e("strong",[t._v("将修改state的逻辑")]),t._v("编写到了组件之中，就会导致组件"),e("strong",[t._v("不断的循环渲染")]),t._v("，直至调用次数过多内存溢出。\n（汉堡APP的"),e("a",{attrs:{href:"https://github.com/Fancy911/React18-Hooks-LearningDemo/blob/main/react-app-hanbao/src/components/Cart/index.jsx",target:"_blank",rel:"noopener noreferrer"}},[t._v("购物车Cart组件"),e("OutboundLink")],1),t._v("中有说明）")]),t._v(" "),e("h2",{attrs:{id:"react-strictmode"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-strictmode"}},[t._v("#")]),t._v(" "),e("code",[t._v("React.StrictMode")])]),t._v(" "),e("p",[t._v("编写"),e("code",[t._v("React")]),t._v("组件时，我们要极力的避免组件中出现那些会产生“副作用”的代码。")]),t._v(" "),e("p",[t._v("同时，如果你的"),e("code",[t._v("React")]),t._v("使用了严格模式，也就是在"),e("code",[t._v("React")]),t._v("中使用了"),e("code",[t._v("React.StrictMode")]),t._v("标签，那么"),e("code",[t._v("React")]),t._v("会非常“智能”的去检查你的组件中是否写有副作用的代码，当然这个智能是加了引号的，我们来看看"),e("code",[t._v("React")]),t._v("官网的文档是如何说明的：")]),t._v(" "),e("blockquote",[e("p",[t._v("Strict mode can’t automatically detect side effects for you, but it can help you spot them by making them a little more deterministic. This is done by intentionally double-invoking the following functions:")]),t._v(" "),e("ul",[e("li",[t._v("Class component constructor, render, and shouldComponentUpdate methods")]),t._v(" "),e("li",[t._v("Class component static getDerivedStateFromProps method")]),t._v(" "),e("li",[t._v("Function component bodies")]),t._v(" "),e("li",[t._v("State updater functions (the first argument to setState)")]),t._v(" "),e("li",[t._v("Functions passed to useState, useMemo, or useReducer")])])]),t._v(" "),e("p",[t._v("上文的关键字叫做"),e("code",[t._v("“double-invoking”")]),t._v("，即"),e("strong",[t._v("重复调用")]),t._v("，这句话是什么意思呢？")]),t._v(" "),e("p",[t._v("大概意思就是，"),e("code",[t._v("React")]),t._v("并不能自动替你发现副作用，但是它会想办法让它显现出来，从而让你发现它。")]),t._v(" "),e("p",[t._v("那么它是怎么让你发现副作用的呢？")]),t._v(" "),e("p",[e("code",[t._v("React")]),t._v("的严格模式，在处于开发模式下，会主动的重复调用一些函数，以使副作用显现。所以在处于开发模式且开启了React严格模式时，以下函数会被调用两次:")]),t._v(" "),e("ul",[e("li",[t._v("类组件的的 "),e("code",[t._v("constructor")]),t._v(", "),e("code",[t._v("render")]),t._v(", 和 "),e("code",[t._v("shouldComponentUpdate")]),t._v(" 方法")]),t._v(" "),e("li",[t._v("类组件的静态方法 "),e("code",[t._v("getDerivedStateFromProps")])]),t._v(" "),e("li",[t._v("函数组件的函数体")]),t._v(" "),e("li",[t._v("参数为函数的"),e("code",[t._v("setState")])]),t._v(" "),e("li",[t._v("参数为函数的"),e("code",[t._v("useState")]),t._v(", "),e("code",[t._v("useMemo")]),t._v(", 或 "),e("code",[t._v("useReducer")])])]),t._v(" "),e("p",[t._v("重复的调用会使副作用更容易凸显出来，你可以尝试着在函数组件的函数体中调用一个"),e("code",[t._v("console.log")]),t._v("你会发现它会"),e("strong",[t._v("执行两次")]),t._v("，如果你的浏览器中安装了"),e("code",[t._v("React Developer Tools")]),t._v("，第二次调用会"),e("strong",[t._v("显示为灰色")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"使用effect-useeffect"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用effect-useeffect"}},[t._v("#")]),t._v(" 使用"),e("code",[t._v("Effect")]),t._v("——"),e("code",[t._v("useEffect")])]),t._v(" "),e("p",[t._v("为了解决这个问题React专门为我们提供了钩子函数"),e("code",[t._v("useEffect()")]),t._v("，"),e("code",[t._v("Effect")]),t._v("的翻译过来就是副作用，专门用来处理那些不能直接写在组件内部的代码。")]),t._v(" "),e("p",[t._v("哪些代码不能直接写在组件内部呢？像是：获取数据、记录日志、检查登录、设置定时器等。简单来说，就是那些和组件渲染无关，但却有可能对组件产生副作用的代码。")]),t._v(" "),e("h3",{attrs:{id:"第一个参数-回调函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一个参数-回调函数"}},[t._v("#")]),t._v(" 第一个参数-回调函数")]),t._v(" "),e("div",{staticClass:"language-jsx line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-jsx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("useEffect")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("didUpdate"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[e("code",[t._v("useEffect()")]),t._v("需要一个函数作为参数，你可以这样写：")]),t._v(" "),e("div",{staticClass:"language-jsx line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-jsx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("useEffect")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 编写那些会产生副作用的代码 */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("p",[e("code",[t._v("useEffect()")]),t._v("中的回调函数会在组件每次渲染完毕之后执行，这也是它和写在函数体中代码的最大的不同，函数体中的代码会在组件渲染前执行，而"),e("code",[t._v("useEffect()")]),t._v("中的代码是在组件渲染后才执行，这就避免了代码的执行影响到组件渲染。")]),t._v(" "),e("p",[t._v("通过使用这个"),e("code",[t._v("Hook")]),t._v("，我设置了"),e("code",[t._v("React")]),t._v("组件在渲染后所要执行的操作。"),e("code",[t._v("React")]),t._v("会将我们传递的函数保存（我们称这个函数为"),e("code",[t._v("effect")]),t._v("），并且在DOM更新后执行调用它。"),e("code",[t._v("React")]),t._v("会确保"),e("code",[t._v("effect")]),t._v("每次运行时，DOM都已经更新完毕。")]),t._v(" "),e("h3",{attrs:{id:"第二个参数-useeffect的依赖项数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二个参数-useeffect的依赖项数组"}},[t._v("#")]),t._v(" 第二个参数-"),e("code",[t._v("useEffect")]),t._v("的依赖项数组")]),t._v(" "),e("p",[t._v("组件每次渲染effect都会执行，这似乎并不总那么必要。因此在"),e("code",[t._v("useEffect()")]),t._v("中我们可以限制"),e("code",[t._v("effect")]),t._v("的执行时机，在"),e("code",[t._v("useEffect()")]),t._v("中可以"),e("strong",[t._v("将一个数组作为第二个参数传递")]),t._v("，像是这样：")]),t._v(" "),e("div",{staticClass:"language-jsx line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-jsx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("useEffect")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 编写那些会产生副作用的代码 */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("p",[t._v("上例中，数组中有两个变量"),e("code",[t._v("a")]),t._v("和"),e("code",[t._v("b")]),t._v("，设置以后"),e("code",[t._v("effect")]),t._v("只有在变量"),e("code",[t._v("a")]),t._v("或"),e("code",[t._v("b")]),t._v("发生变化时才会执行。这样即可限制"),e("code",[t._v("effect")]),t._v("的执行次数。")]),t._v(" "),e("p",[t._v("也可以直接传递一个空数组，如果依赖项是一个空数组"),e("code",[t._v("[]")]),t._v("，那么"),e("code",[t._v("effect")]),t._v("只会执行一次。")]),t._v(" "),e("h3",{attrs:{id:"清除effect-useeffect的返回值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#清除effect-useeffect的返回值"}},[t._v("#")]),t._v(" 清除"),e("code",[t._v("Effect")]),t._v("——"),e("code",[t._v("useEffect")]),t._v("的返回值")]),t._v(" "),e("p",[t._v("组件的每次重新渲染"),e("code",[t._v("effect")]),t._v("都会执行，有一些情况里，两次"),e("code",[t._v("effect")]),t._v("执行会互相影响。")]),t._v(" "),e("p",[t._v("比如，在"),e("code",[t._v("effect")]),t._v("中设置了一个定时器，总不能每次"),e("code",[t._v("effect")]),t._v("执行都设置一个新的定时器，所以我们需要在一个"),e("code",[t._v("effect")]),t._v("执行前，清除掉前一个"),e("code",[t._v("effect")]),t._v("所带来的影响。")]),t._v(" "),e("p",[t._v("要实现这个功能，可以在"),e("code",[t._v("effect")]),t._v("中将一个函数作为返回值返回，像是这样：")]),t._v(" "),e("div",{staticClass:"language-jsx line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-jsx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("useEffect")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 编写那些会产生副作用的代码 */")]),t._v("\n    \n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 这个函数会在下一次effect执行钱调用 */")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br")])]),e("p",[e("code",[t._v("effect")]),t._v("返回的函数，会在下一次"),e("code",[t._v("effect")]),t._v("执行前调用，我们可以在这个函数中清除掉前一次"),e("code",[t._v("effect")]),t._v("执行所带来的影响。")]),t._v(" "),e("h2",{attrs:{id:"使用effect实现的app的代码页面展示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用effect实现的app的代码页面展示"}},[t._v("#")]),t._v(" 使用Effect实现的APP的代码页面展示")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/Fancy911/React18-Hooks-LearningDemo/blob/main/react-app-hanbao/src/components/Cart/index.jsx",target:"_blank",rel:"noopener noreferrer"}},[t._v("Cart购物车组件"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/Fancy911/React18-Hooks-LearningDemo/blob/main/react-app-hanbao/src/components/Filter/index.jsx",target:"_blank",rel:"noopener noreferrer"}},[t._v("Filter搜索框组件"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=n.exports}}]);